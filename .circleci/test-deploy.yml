version: 2.1
orbs:
  # Your orb will be automatically injected here during the pipeline.
  # Reference your orb's jobs and commands below as they will exist when built.
  orb-tools: circleci/orb-tools@12.3
  # The orb definition is intentionally not included here. It will be injected into the pipeline.
  cosign-orb: {}

# Use this tag to ensure test jobs always run,
# even though the downstream publish job will only run on release tags.
filters: &filters
  tags:
    only: /.*/

# Filter for release tags.
release-filters: &release-filters
  branches:
    ignore: /.*/
  tags:
    only: /^v[0-9]+\.[0-9]+\.[0-9]+$/

executors:
  docker-executor:
    docker:
      - image: cimg/base:current-22.04

jobs:
  # Test install command with default version (v3)
  test-install-default:
    executor: docker-executor
    steps:
      - checkout
      - cosign-orb/install
      - run:
          name: Verify Cosign installed
          command: command -v cosign
      - run:
          name: Verify Cosign version is v3
          command: |
            VERSION=$(cosign version --json 2>&1 | jq -r '.gitVersion')
            echo "Installed version: ${VERSION}"
            if [[ ! "${VERSION}" =~ ^v3\. ]]; then
              echo "ERROR: Expected v3.x, got ${VERSION}"
              exit 1
            fi

  # Test install command with specific v3 version
  test-install-v3:
    executor: docker-executor
    steps:
      - checkout
      - cosign-orb/install:
          version: "3.0.3"
      - run:
          name: Verify Cosign version
          command: |
            VERSION=$(cosign version --json 2>&1 | jq -r '.gitVersion')
            echo "Installed version: ${VERSION}"
            if [[ "${VERSION}" != "v3.0.3" ]]; then
              echo "ERROR: Expected v3.0.3, got ${VERSION}"
              exit 1
            fi

  # Test install command with specific v2 version
  test-install-v2:
    executor: docker-executor
    steps:
      - checkout
      - cosign-orb/install:
          version: "2.5.3"
      - run:
          name: Verify Cosign version
          command: |
            VERSION=$(cosign version --json 2>&1 | jq -r '.gitVersion')
            echo "Installed version: ${VERSION}"
            if [[ "${VERSION}" != "v2.5.3" ]]; then
              echo "ERROR: Expected v2.5.3, got ${VERSION}"
              exit 1
            fi

  # Test install command with specific v1 version
  test-install-v1:
    executor: docker-executor
    steps:
      - checkout
      - cosign-orb/install:
          version: "1.13.6"
      - run:
          name: Verify Cosign version
          command: |
            VERSION=$(cosign version --json 2>&1 | jq -r '.gitVersion')
            echo "Installed version: ${VERSION}"
            if [[ "${VERSION}" != "v1.13.6" ]]; then
              echo "ERROR: Expected v1.13.6, got ${VERSION}"
              exit 1
            fi

  # Test install with strict checksum verification
  test-install-checksum-strict:
    executor: docker-executor
    steps:
      - checkout
      - cosign-orb/install:
          version: "3.0.4"
          verify_checksums: strict
      - run:
          name: Verify install succeeded with strict checksums
          command: cosign version

  # Integration test: sign and verify image with Cosign v3
  integration-test-v3:
    docker:
      - image: cimg/base:current-22.04
    environment:
      IMAGE_TTL: 1h
    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: true
      - cosign-orb/install:
          version: "3.0.4"
      - cosign-orb/generate_key_pair:
          password: "test-password-v3"
      - run:
          name: Generate unique image reference
          command: |
            # Use CircleCI workflow ID for uniqueness
            IMAGE_UUID=$(echo "${CIRCLE_WORKFLOW_ID}" | head -c 8)
            IMAGE_REF="ttl.sh/cosign-orb-test-${IMAGE_UUID}:${IMAGE_TTL}"
            echo "export IMAGE_REF='${IMAGE_REF}'" >> "${BASH_ENV}"
            echo "Test image: ${IMAGE_REF}"
      - run:
          name: Build and push test image
          command: |
            # SECURITY: ttl.sh is a third-party service. DO NOT include sensitive data in test images.
            echo "Test image built at $(date -u +%Y-%m-%dT%H:%M:%SZ)" > testfile.txt
            printf 'FROM scratch\nCOPY testfile.txt /testfile.txt\n' > Dockerfile
            docker build -t "${IMAGE_REF}" .
            # Push directly to ttl.sh (anonymous push supported)
            docker push "${IMAGE_REF}"
            echo "Pushed test image to ${IMAGE_REF}"
      - cosign-orb/sign_image:
          image: ${IMAGE_REF}
          annotations: "build.source=circleci,build.version=v3"
      - cosign-orb/verify_image:
          image: ${IMAGE_REF}
      - run:
          name: Verify annotations are present in signature
          command: |
            # Verify signature with annotation check - fails if annotation doesn't match
            # Check both annotations to verify comma-separated parsing works
            printf '%s' "${COSIGN_PUBLIC_KEY}" | base64 --decode > cosign-verify.pub
            cosign verify --key cosign-verify.pub --private-infrastructure -a build.source=circleci -a build.version=v3 "${IMAGE_REF}"
            rm -f cosign-verify.pub
            echo "Annotations verified successfully"
      - run:
          name: Create test attestation predicate
          command: |
            printf '{"buildType":"https://example.com/test-build","builder":{"id":"https://circleci.com"},"invocation":{"configSource":{}}}\n' > predicate.json
      - cosign-orb/attest:
          image: ${IMAGE_REF}
          predicate: predicate.json
          predicate_type: slsaprovenance
      - cosign-orb/verify_attestation:
          image: ${IMAGE_REF}
          predicate_type: slsaprovenance

  # Integration test: sign and verify image with Cosign v2
  integration-test-v2:
    docker:
      - image: cimg/base:current-22.04
    environment:
      IMAGE_TTL: 1h
    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: true
      - cosign-orb/install:
          version: "2.5.3"
      - cosign-orb/generate_key_pair:
          password: "test-password-v2"
      - run:
          name: Generate unique image reference
          command: |
            IMAGE_UUID=$(echo "${CIRCLE_WORKFLOW_ID}" | head -c 8)
            # Use different suffix to avoid collision with v3 test
            IMAGE_REF="ttl.sh/cosign-orb-test-v2-${IMAGE_UUID}:${IMAGE_TTL}"
            echo "export IMAGE_REF='${IMAGE_REF}'" >> "${BASH_ENV}"
            echo "Test image: ${IMAGE_REF}"
      - run:
          name: Build and push test image
          command: |
            # SECURITY: ttl.sh is a third-party service. DO NOT include sensitive data in test images.
            echo "Test image built at $(date -u +%Y-%m-%dT%H:%M:%SZ)" > testfile.txt
            printf 'FROM scratch\nCOPY testfile.txt /testfile.txt\n' > Dockerfile
            docker build -t "${IMAGE_REF}" .
            # Push directly to ttl.sh (anonymous push supported)
            docker push "${IMAGE_REF}"
            echo "Pushed test image to ${IMAGE_REF}"
      - cosign-orb/sign_image:
          image: ${IMAGE_REF}
          annotations: "build.source=circleci,build.version=v2"
      - cosign-orb/verify_image:
          image: ${IMAGE_REF}
      - run:
          name: Verify annotations are present in signature
          command: |
            # Verify signature with annotation check - fails if annotation doesn't match
            # Check both annotations to verify comma-separated parsing works
            printf '%s' "${COSIGN_PUBLIC_KEY}" | base64 --decode > cosign-verify.pub
            cosign verify --key cosign-verify.pub --private-infrastructure -a build.source=circleci -a build.version=v2 "${IMAGE_REF}"
            rm -f cosign-verify.pub
            echo "Annotations verified successfully"
      - run:
          name: Create test attestation predicate
          command: |
            printf '{"buildType":"https://example.com/test-build","builder":{"id":"https://circleci.com"},"invocation":{"configSource":{}}}\n' > predicate.json
      - cosign-orb/attest:
          image: ${IMAGE_REF}
          predicate: predicate.json
          predicate_type: slsaprovenance
      - cosign-orb/verify_attestation:
          image: ${IMAGE_REF}
          predicate_type: slsaprovenance

  # Integration test: sign and verify image with Cosign v1
  # NOTE: v1 uses a different key format than v2/v3, so we generate keys dynamically
  integration-test-v1:
    docker:
      - image: cimg/base:current-22.04
    environment:
      IMAGE_TTL: 1h
    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: true
      - cosign-orb/install:
          version: "1.13.6"
      - cosign-orb/generate_key_pair:
          password: "test-password-v1"
      - run:
          name: Generate unique image reference
          command: |
            IMAGE_UUID=$(echo "${CIRCLE_WORKFLOW_ID}" | head -c 8)
            # Use different suffix to avoid collision with other tests
            IMAGE_REF="ttl.sh/cosign-orb-test-v1-${IMAGE_UUID}:${IMAGE_TTL}"
            echo "export IMAGE_REF='${IMAGE_REF}'" >> "${BASH_ENV}"
            echo "Test image: ${IMAGE_REF}"
      - run:
          name: Build and push test image
          command: |
            # SECURITY: ttl.sh is a third-party service. DO NOT include sensitive data in test images.
            echo "Test image built at $(date -u +%Y-%m-%dT%H:%M:%SZ)" > testfile.txt
            printf 'FROM scratch\nCOPY testfile.txt /testfile.txt\n' > Dockerfile
            docker build -t "${IMAGE_REF}" .
            # Push directly to ttl.sh (anonymous push supported)
            docker push "${IMAGE_REF}"
            echo "Pushed test image to ${IMAGE_REF}"
      - cosign-orb/sign_image:
          image: ${IMAGE_REF}
          annotations: "build.source=circleci,build.version=v1"
      - cosign-orb/verify_image:
          image: ${IMAGE_REF}
      - run:
          name: Verify annotations are present in signature
          command: |
            # Verify signature with annotation check - fails if annotation doesn't match
            # Check both annotations to verify comma-separated parsing works
            # Note: v1 doesn't use --private-infrastructure flag
            printf '%s' "${COSIGN_PUBLIC_KEY}" | base64 --decode > cosign-verify.pub
            cosign verify --key cosign-verify.pub -a build.source=circleci -a build.version=v1 "${IMAGE_REF}"
            rm -f cosign-verify.pub
            echo "Annotations verified successfully"
      - run:
          name: Create test attestation predicate
          command: |
            printf '{"buildType":"https://example.com/test-build","builder":{"id":"https://circleci.com"},"invocation":{"configSource":{}}}\n' > predicate.json
      - cosign-orb/attest:
          image: ${IMAGE_REF}
          predicate: predicate.json
          predicate_type: slsaprovenance
      - cosign-orb/verify_attestation:
          image: ${IMAGE_REF}
          predicate_type: slsaprovenance

  # Integration test: sign and verify blob with Cosign v3
  integration-test-blob-v3:
    executor: docker-executor
    steps:
      - checkout
      - cosign-orb/install:
          version: "3.0.4"
      - cosign-orb/generate_key_pair:
          password: "test-password-blob-v3"
      - run:
          name: Create test blob file
          command: |
            # SECURITY: DO NOT include sensitive data in test files
            echo "Test blob created at $(date -u +%Y-%m-%dT%H:%M:%SZ)" > testblob.txt
            echo "Created test blob: testblob.txt"
      - cosign-orb/sign_blob:
          blob: testblob.txt
          signature_output: testblob.txt.sig
      - run:
          name: Verify signature file was created
          command: |
            if [[ ! -f testblob.txt.sig ]]; then
              echo "ERROR: Signature file was not created"
              exit 1
            fi
            echo "Signature file exists: testblob.txt.sig"
      - cosign-orb/verify_blob:
          blob: testblob.txt
          signature: testblob.txt.sig

  # Integration test: sign and verify blob with Cosign v2
  integration-test-blob-v2:
    executor: docker-executor
    steps:
      - checkout
      - cosign-orb/install:
          version: "2.5.3"
      - cosign-orb/generate_key_pair:
          password: "test-password-blob-v2"
      - run:
          name: Create test blob file
          command: |
            # SECURITY: DO NOT include sensitive data in test files
            echo "Test blob created at $(date -u +%Y-%m-%dT%H:%M:%SZ)" > testblob.txt
            echo "Created test blob: testblob.txt"
      - cosign-orb/sign_blob:
          blob: testblob.txt
          signature_output: testblob.txt.sig
      - run:
          name: Verify signature file was created
          command: |
            if [[ ! -f testblob.txt.sig ]]; then
              echo "ERROR: Signature file was not created"
              exit 1
            fi
            echo "Signature file exists: testblob.txt.sig"
      - cosign-orb/verify_blob:
          blob: testblob.txt
          signature: testblob.txt.sig

  # Integration test: sign and verify blob with Cosign v1
  integration-test-blob-v1:
    executor: docker-executor
    steps:
      - checkout
      - cosign-orb/install:
          version: "1.13.6"
      - cosign-orb/generate_key_pair:
          password: "test-password-blob-v1"
      - run:
          name: Create test blob file
          command: |
            # SECURITY: DO NOT include sensitive data in test files
            echo "Test blob created at $(date -u +%Y-%m-%dT%H:%M:%SZ)" > testblob.txt
            echo "Created test blob: testblob.txt"
      - cosign-orb/sign_blob:
          blob: testblob.txt
          signature_output: testblob.txt.sig
      - run:
          name: Verify signature file was created
          command: |
            if [[ ! -f testblob.txt.sig ]]; then
              echo "ERROR: Signature file was not created"
              exit 1
            fi
            echo "Signature file exists: testblob.txt.sig"
      - cosign-orb/verify_blob:
          blob: testblob.txt
          signature: testblob.txt.sig

workflows:
  test-deploy:
    jobs:
      # Install tests - no context needed
      - test-install-default:
          filters: *filters
      - test-install-v3:
          filters: *filters
      - test-install-v2:
          filters: *filters
      - test-install-v1:
          filters: *filters
      - test-install-checksum-strict:
          filters: *filters

      # Integration tests - generate throwaway keys, no context needed
      - integration-test-v3:
          filters: *filters
      - integration-test-v2:
          filters: *filters
      - integration-test-v1:
          filters: *filters

      # Blob integration tests - generate throwaway keys, no context needed
      - integration-test-blob-v3:
          filters: *filters
      - integration-test-blob-v2:
          filters: *filters
      - integration-test-blob-v1:
          filters: *filters

      # Orb publishing
      - orb-tools/pack:
          filters: *release-filters
      - orb-tools/publish:
          orb_name: juburr/cosign-orb
          vcs_type: << pipeline.project.type >>
          pub_type: production
          requires:
            - orb-tools/pack
            - test-install-default
            - test-install-v3
            - test-install-v2
            - test-install-v1
            - test-install-checksum-strict
            - integration-test-v3
            - integration-test-v2
            - integration-test-v1
            - integration-test-blob-v3
            - integration-test-blob-v2
            - integration-test-blob-v1
          context: orb-publishing
          filters: *release-filters
